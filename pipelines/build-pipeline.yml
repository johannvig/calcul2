trigger:
- main
# Déclenche le pipeline lorsque des changements sont poussés sur la branche `main`

pool: 'default'
# Utilise l'agent par défaut pour exécuter le pipeline

variables:
  ServiceBusConnectionString: 'Endpoint=sb://devoirguro.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=TKKcqPGJw9JYIQNwikA4Ihv2qejQwxFvx+ASbKBLad4='
# Définit une variable contenant la chaîne de connexion pour Azure Service Bus

steps:
# Étape 1 : Installation du SDK .NET 8.x
- task: UseDotNet@2
  displayName: 'Installer .NET SDK 8.x'
  inputs:
    packageType: 'sdk'
    version: '8.0.100'

# Étape 2 : Restauration des dépendances du projet
- script: |
    dotnet restore
  workingDirectory: './azure-functions'
  displayName: 'Restaurer les dépendances'

# Étape 2.1 : Lister les dépendances NuGet du projet
- script: |
    dotnet list package
  workingDirectory: './azure-functions'
  displayName: 'Lister les dépendances NuGet'

# Étape 3 : Compiler le projet en mode Release
- script: |
    dotnet build -c Release
  workingDirectory: './azure-functions'
  displayName: 'Compiler le projet'

# Étape 4 : Publier le projet dans un répertoire spécifique
- script: |
    dotnet publish -c Release -o ./publishs
  workingDirectory: './azure-functions'
  displayName: 'Publier le projet'

# Étape 4.2 : Vérification des fichiers publiés
- script: |
    echo "Répertoire actuel : $(System.DefaultWorkingDirectory)"
    echo "Contenu du répertoire azure-functions :"
    dir "$(System.DefaultWorkingDirectory)\azure-functions"
    echo "Contenu du répertoire publishs :"
    dir "$(System.DefaultWorkingDirectory)\azure-functions\publishs"
  displayName: 'Vérifier les fichiers publiés'

# Étape 5 : Archiver les fichiers publiés en un fichier ZIP
- task: ArchiveFiles@2
  displayName: 'Archiver les fichiers publiés'
  inputs:
    rootFolderOrFile: '$(System.DefaultWorkingDirectory)/azure-functions/publishs'
    archiveFile: '$(Build.ArtifactStagingDirectory)/azure-functions.zip'
    archiveType: 'zip'

# Étape 5.1 : Vérifier le contenu du fichier ZIP créé
- script: |
    echo "Vérification du contenu du fichier azure-functions.zip"
    tar -tf $(Build.ArtifactStagingDirectory)/azure-functions.zip
  displayName: 'Vérifier le contenu du package ZIP'

# Étape 6 : Publier l'artefact de build
- task: PublishBuildArtifacts@1
  displayName: 'Publier l’artefact'
  inputs:
    pathToPublish: '$(Build.ArtifactStagingDirectory)'
    artifactName: 'FunctionApp'

# Étape 7 : Déployer le Blob Storage
- task: AzureResourceManagerTemplateDeployment@3
  displayName: 'Déployer le Blob Storage'
  inputs:
    azureResourceManagerConnection: 'Azure subscription 1(2)(4752c137-48fe-4a21-ac6e-435c1d51dbe9)'
    resourceGroupName: 'Projet-2'
    location: 'canadacentral'
    templateLocation: 'Linked artifact'
    csmFile: 'infra/azuredeploy-storage.json'
    csmParametersFile: 'infra/parameters-storage.json'

# Étape 8 : Déployer le Service Bus
- task: AzureResourceManagerTemplateDeployment@3
  displayName: 'Déployer le Service Bus'
  inputs:
    azureResourceManagerConnection: 'Azure subscription 1(2)(4752c137-48fe-4a21-ac6e-435c1d51dbe9)'
    resourceGroupName: 'Projet-2'
    location: 'canadacentral'
    templateLocation: 'Linked artifact'
    csmFile: 'infra/azuredeploy-servicebus.json'
    csmParametersFile: 'infra/parameters-servicebus.json'

# Étape 9 : Attendre la disponibilité du Service Bus
- task: PowerShell@2
  displayName: 'Attente de la disponibilité du Service Bus'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Attente de 30 secondes pour la disponibilité du Service Bus..."
      Start-Sleep -Seconds 30

# Étape 10 : Vérifier l'existence du namespace Service Bus
- task: AzureCLI@2
  displayName: 'Vérifier l’existence du Service Bus'
  inputs:
    azureSubscription: 'Azure subscription 1(2)(4752c137-48fe-4a21-ac6e-435c1d51dbe9)'
    scriptType: 'ps'
    scriptLocation: 'inlineScript'
    inlineScript: |
      az servicebus namespace show `
        --resource-group 'Projet-2' `
        --name 'AzureBus-TMEB'

# Étape 11 : Récupérer la clé de connexion Service Bus
- task: AzureCLI@2
  displayName: 'Récupérer la clé de connexion Service Bus'
  inputs:
    azureSubscription: 'Azure subscription 1(2)(4752c137-48fe-4a21-ac6e-435c1d51dbe9)'
    scriptType: 'ps'
    scriptLocation: 'inlineScript'
    inlineScript: |
      $CONNECTION_STRING = az servicebus namespace authorization-rule keys list `
        --resource-group 'Projet-2' `
        --namespace-name 'AzureBus-TMEB' `
        --name 'RootManageSharedAccessKey' `
        --query 'primaryConnectionString' -o tsv
      Write-Host "##vso[task.setvariable variable=ServiceBusConnectionString]$CONNECTION_STRING"
  condition: succeeded()

# Étape 12 : Déployer la Function App
- task: AzureResourceManagerTemplateDeployment@3
  displayName: 'Déployer la Function App'
  inputs:
    azureResourceManagerConnection: 'Azure subscription 1(2)(4752c137-48fe-4a21-ac6e-435c1d51dbe9)'
    resourceGroupName: 'Projet-2'
    location: 'canadacentral'
    templateLocation: 'Linked artifact'
    csmFile: 'infra/azuredeploy-function.json'
    csmParametersFile: 'infra/parameters-function.json'
    overrideParameters: >
      -serviceBusConnectionString "$(ServiceBusConnectionString)"

# Étape 13 : Déployer les fonctions dans la Function App
- task: AzureFunctionApp@1
  inputs:
    azureSubscription: 'Azure subscription 1(2)(4752c137-48fe-4a21-ac6e-435c1d51dbe9)'
    appType: 'functionApp'
    appName: 'FunctionAppProjet23'
    package: '$(System.DefaultWorkingDirectory)/azure-functions.zip'

# Étape 14 : Vérification finale
- script: |
    echo "Clé Service Bus utilisée : $(ServiceBusConnectionString)"
    echo "Déploiement terminé avec succès."
  displayName: 'Vérification finale'
